<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <!-- 写模板 -->
    <div id="root">
      <div><p>{{name}}--{{message}}</p></div>

      <p>{{name}}</p>
      <p>{{message}}</p>
    </div>
  </body>

  <script>
    //第二步 创建实例

    //步骤解析
    //1.拿到模板
    //2.拿到数据（data）
    //3.将数据和模板结合。得到的是HTML DOM元素
    //4.放到页面中

    //1

    let rkuohao = /\{\{(.+?)\}\}/g;

    let tmpNode = document.querySelector("#root");

    //2
    let data = {
      name: "一个新name",
      message: "一个消息",
    };

    //3
    //一般使用 递归
    //在现在这个案例中，这个template是DOM元素。在真正的VUE源码中是DOM->字符串模板->VNode（虚拟DOM）->真正的DOM。
    function compiler(template, data) {
      let childNodes = template.childNodes;
      for (let i = 0; i < childNodes.length; i++) {
        let type = childNodes[i].nodeType; //1 元素，3 文本节点
        if (type === 3) {
          //文本节点可以判断里面是否有双括弧的差值
          let txt = childNodes[i].nodeValue; //该元素只有文本节点才有意义

          //判断有没有花括号
          txt = txt.replace(rkuohao, function (_, g) {
            //使用正则匹配一次函数就会调用一次，函数的第0个参数表示匹配到的内容，函数中的第n个参数表示正则中的第n组（一个括号表示一组）

            let key = g.trim(); //只取写在花括号里面的东西
            let value = data[key];

            //将{{xxxx}}用这个值替换

            return value;
          });

          //注意 现在txt 和 DOM元素是没有关系的
          childNodes[i].nodeValue = txt;
        } else if (type === 1) {
          //元素需要考虑他有没有子元素，是否需要对其子元素进行判断是否具有插值
          compiler(childNodes[i], data);
        }
      }
    }

    // console.log(tmpNode);
    // compiler(tmpNode, data);

    // console.log(tmpNode);

    //这样会有一些问题，我们此时没有生成新的template，页面会直接吧{{name}}\{{message}}模板的坑都变为填入的值，坑就没有了，如果后面还要修改name和message的值，就会出现问题

    //所以需要拷贝一份tmpNodes,修改拷贝的temNodes

    //利用模板生成一个 需要被渲染安的HTML标签（准真正在页面中渲染的标签）
    let generateNode = tmpNode.cloneNode(true); //true的意思是包括克隆该元素的子元素

    console.log(tmpNode);
    //把坑替换为渲染的标签
    compiler(generateNode, data);

    console.log(generateNode);

    //4.用 generateNode（渲染好的HTML） 去替换放在页面中
    root.parentNode.replaceChild(generateNode, root);

    //以上思路有一些问题：1.Vue 使用虚拟DOM 我们现在使用的是真实DOM; 2.只考虑了单属性（{{name}}），Vue中大量使用层级（{{child.name.firstName}}）
    //解决上述问题参考04
  </script>
</html>
